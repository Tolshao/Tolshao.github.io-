<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>template</title>
      <link href="/2020/09/09/template/"/>
      <url>/2020/09/09/template/</url>
      
        <content type="html"><![CDATA[<p>$\pi$</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/08/05/hello-world/"/>
      <url>/2020/08/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre><code class="cpp">class Solution &amp;#123;public:    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &amp;#123;        return quickSort(nums);    &amp;#125;    // 冒泡排序（超时）    vector&lt;int&gt; bubbleSort(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        for (int i = 0; i &lt; n; ++i) &amp;#123;            for (int j = n-2; j &gt;= i; --j) &amp;#123;                if (nums[j] &gt; nums[j+1]) &amp;#123;                    swap(nums[j], nums[j+1]);                &amp;#125;            &amp;#125;        &amp;#125;        return nums;    &amp;#125;    // 选择排序（超时）    vector&lt;int&gt; selectSort(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        for (int i = 0; i &lt; n; ++i) &amp;#123;            int idx = i;            for (int j = i; j &lt; n; ++j) &amp;#123;                if (nums[j] &lt; nums[idx]) &amp;#123;                    idx = j;                &amp;#125;            &amp;#125;            swap(nums[i], nums[idx]);        &amp;#125;        return nums;    &amp;#125;    // 插入排序（超时）    vector&lt;int&gt; insertSort(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        for (int i = 0; i &lt; n; ++i) &amp;#123;            for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; --j) &amp;#123;                swap(nums[j], nums[j-1]);            &amp;#125;        &amp;#125;        return nums;    &amp;#125;    // 快速排序（24 ms）    void qSort(vector&lt;int&gt;&amp; nums, int l, int r) &amp;#123;        if (l &gt;= r) return;        int m = l;        for (int i = l; i &lt; r; ++i) &amp;#123;            if (nums[i] &lt; nums[r]) &amp;#123;                swap(nums[m++], nums[i]);            &amp;#125;        &amp;#125;        swap(nums[m], nums[r]);        qSort(nums, l, m-1);        qSort(nums, m+1, r);    &amp;#125;    vector&lt;int&gt; quickSort(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        qSort(nums, 0, n-1);        return nums;    &amp;#125;    // 归并排序（192 ms）    vector&lt;int&gt; mSort(vector&lt;int&gt;&amp; nums, int l, int r) &amp;#123;        if (l &gt;= r) return &amp;#123;nums[l]&amp;#125;;        int m = l+(r-l)/2;        vector&lt;int&gt; lnums = mSort(nums, l, m);        vector&lt;int&gt; rnums = mSort(nums, m+1, r);        vector&lt;int&gt; res;        int i = 0, j = 0;        while (i &lt;= m-l &amp;&amp; j &lt;= r-m-1) &amp;#123;            if (lnums[i] &lt; rnums[j]) &amp;#123;                res.push_back(lnums[i++]);            &amp;#125; else &amp;#123;                res.push_back(rnums[j++]);            &amp;#125;        &amp;#125;        while (i &lt;= m-l) &amp;#123;            res.push_back(lnums[i++]);        &amp;#125;        while (j &lt;= r-m-1) &amp;#123;            res.push_back(rnums[j++]);        &amp;#125;        return res;    &amp;#125;    vector&lt;int&gt; mergeSort(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        nums = mSort(nums, 0, n-1);        return nums;    &amp;#125;    // 归并排序 + 非递归（80 ms）    vector&lt;int&gt; mergeSortNR(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        for (int len = 1; len &lt; n; len &lt;&lt;= 1) &amp;#123;            for (int l = 0; l &lt; n-len; l += 2*len) &amp;#123;                int m = l+len-1;                int r = min(n-1, l+2*len-1);                vector&lt;int&gt; res;                int i = l, j = m+1;                while (i &lt;= m &amp;&amp; j &lt;= r) &amp;#123;                    if (nums[i] &lt; nums[j]) &amp;#123;                        res.push_back(nums[i++]);                    &amp;#125; else &amp;#123;                        res.push_back(nums[j++]);                    &amp;#125;                &amp;#125;                while (i &lt;= m) &amp;#123;                    res.push_back(nums[i++]);                &amp;#125;                while (j &lt;= r) &amp;#123;                    res.push_back(nums[j++]);                &amp;#125;                for (int i = l; i &lt;= r; ++i) &amp;#123;                    nums[i] = res[i-l];                &amp;#125;            &amp;#125;        &amp;#125;        return nums;    &amp;#125;    // 希尔排序（40 ms）    vector&lt;int&gt; shellSort(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        for (int gap = n/2; gap &gt; 0; gap /= 2) &amp;#123;            for (int i = gap; i &lt; n; ++i) &amp;#123;                for (int j = i; j-gap &gt;= 0 &amp;&amp; nums[j-gap] &gt; nums[j]; j -= gap) &amp;#123;                    swap(nums[j-gap], nums[j]);                &amp;#125;            &amp;#125;        &amp;#125;        return nums;    &amp;#125;    // 计数排序（32 ms）    vector&lt;int&gt; countSort(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        if (!n) return &amp;#123;&amp;#125;;        int minv = *min_element(nums.begin(), nums.end());        int maxv = *max_element(nums.begin(), nums.end());        int m = maxv-minv+1;        vector&lt;int&gt; count(m, 0);        for (int i = 0; i &lt; n; ++i) &amp;#123;            count[nums[i]-minv]++;        &amp;#125;        vector&lt;int&gt; res;        for (int i = 0; i &lt; m; ++i) &amp;#123;            for (int j = 0; j &lt; count[i]; ++j) &amp;#123;                res.push_back(i+minv);            &amp;#125;        &amp;#125;        return res;    &amp;#125;    // 基数排序（不适用于负数）    vector&lt;int&gt; radixSort(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        int maxv = *max_element(nums.begin(), nums.end());        int maxd = 0;        while (maxv &gt; 0) &amp;#123;            maxv /= 10;            maxd++;        &amp;#125;        vector&lt;int&gt; count(10, 0), rank(n, 0);        int base = 1;        while (maxd &gt; 0) &amp;#123;            count.assign(10, 0);            for (int i = 0; i &lt; n; ++i) &amp;#123;                count[(nums[i]/base)%10]++;            &amp;#125;            for (int i = 1; i &lt; 10; ++i) &amp;#123;                count[i] += count[i-1];            &amp;#125;            for (int i = n-1; i &gt;= 0; --i) &amp;#123;                rank[--count[(nums[i]/base)%10]] = nums[i];            &amp;#125;            for (int i = 0; i &lt; n; ++i) &amp;#123;                nums[i] = rank[i];            &amp;#125;            maxd--;            base *= 10;        &amp;#125;        return nums;    &amp;#125;    // 桶排序 (20 ms)    vector&lt;int&gt; bucketSort(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        int maxv = *max_element(nums.begin(), nums.end());        int minv = *min_element(nums.begin(), nums.end());        int bs = 1000;        int m = (maxv-minv)/bs+1;        vector&lt;vector&lt;int&gt; &gt; bucket(m);        for (int i = 0; i &lt; n; ++i) &amp;#123;            bucket[(nums[i]-minv)/bs].push_back(nums[i]);        &amp;#125;        int idx = 0;        for (int i = 0; i &lt; m; ++i) &amp;#123;            int sz = bucket[i].size();            bucket[i] = quickSort(bucket[i]);            for (int j = 0; j &lt; sz; ++j) &amp;#123;                nums[idx++] = bucket[i][j];            &amp;#125;        &amp;#125;        return nums;    &amp;#125;    // 堆排序（32 ms）    void adjust(vector&lt;int&gt;&amp; nums, int p, int s) &amp;#123;        while (2*p+1 &lt; s) &amp;#123;            int c1 = 2*p+1;            int c2 = 2*p+2;            int c = (c2&lt;s &amp;&amp; nums[c2]&gt;nums[c1]) ? c2 : c1;            if (nums[c] &gt; nums[p]) swap(nums[c], nums[p]);            else break;            p = c;        &amp;#125;    &amp;#125;    vector&lt;int&gt; heapSort(vector&lt;int&gt;&amp; nums) &amp;#123;        int n = nums.size();        for (int i = n/2-1; i &gt;= 0; --i) &amp;#123;            adjust(nums, i, n);        &amp;#125;        for (int i = n-1; i &gt; 0; --i) &amp;#123;            swap(nums[0], nums[i]);            adjust(nums, 0, i);        &amp;#125;        return nums;    &amp;#125;&amp;#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
